package graph_clustering;

import java.util.Vector;

public class graph_communities_and_fitness {
	Vector<Float> sorted_eigen_value ;
	Vector<Vector<Float>> sorted_eigen_vector ; 
	
	//this may update by this algorithm so PSO needs 2 things here
	Vector<Float> pso_results_at_every_iteration ; 
	
	//Instead of quantization error in data clustering here it requires Q value
	// ********** Q value is optimized to max instead where 
	// ********** PSO for data clustering quantization error is optimized to minimum value
	float Q_value_for_this_iteration ; 
	
	int n ; //number of communities center
	//pso based center for which flag greater than equal to 0.5
	// we will change this estimation we respect to eigen vector whose eigen value is more
	Vector<Float> center_estimated_by_pso ; 
	
	public graph_communities_and_fitness(Vector<Float> sorted_eigen_value , Vector<Vector<Float>> sorted_eigen_vector) {
		// TODO Auto-generated constructor stub
		this.sorted_eigen_value = sorted_eigen_value ; 
		this.sorted_eigen_vector = sorted_eigen_vector ; 
	}
	
	public void graph_cluster_at_every_pso_iteration(Vector<Float> pso_results_at_every_iteration)
	{
		this.pso_results_at_every_iteration = pso_results_at_every_iteration ; 
		pso_results_rounding_off() ; 
	}
	
	public float get_Q_value_for_this_iteration()
	{
		return Q_value_for_this_iteration ; 
	}
	
	// this is because step 2 in research paper of "PSO based graph clustering"
	// flag value are changed flag_p = 1- 0.5 * rand(0,1) flag_q = 1- 0.5 * rand(0,1)
	// this is may or may not happen so safe side take value from here
	public Vector<Float> get_particle_new_position()
	{
		return pso_results_at_every_iteration ; 
	}
	
	//step 1 
	public void pso_results_rounding_off()
	{
		int size_of_particle_dimension = pso_results_at_every_iteration.size() ; 
		
	}
	
	
	
	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}
