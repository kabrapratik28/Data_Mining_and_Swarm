package graph_clustering;

import java.util.HashMap;
import java.util.Map;
import java.util.Vector;

public class make_communities_according_to_dissimilarity {
	//set eigen values and eigen vectors
	Vector<Float> eigen_values ; 
	Vector< Vector<Float> > eigen_vector ;
	
	//first selected (no of centroids -1) eigen value and eigen vector  are sended
	public make_communities_according_to_dissimilarity(Vector<Float> eigen_values, Vector< Vector<Float> > eigen_vector)
	{
		if (eigen_values.size() != eigen_vector.size())
		{
			System.out.println("Error : eigen Value and eigen Vector size are not same. ");
		}
		else 
		{
			this.eigen_values = eigen_values ;
			this.eigen_vector = eigen_vector ;
		}
	}
	

	//return nodes which are closer to each other in graph matrix 
	// map of centroid number and respective vector sends
	public Map<Integer, Vector<Integer>>  community_find_out_of_given_centroid(Vector<Integer> centroid_number_in_graph)
	{
		Map<Integer, Vector<Integer>> centroid_no_to_element_vec = new HashMap<Integer, Vector<Integer>>();
		
		// setting dictionary with empty element 
		for (int centroid_counter = 0 ; centroid_counter < centroid_number_in_graph.size() ; centroid_counter++ )
		{
			centroid_no_to_element_vec.put(centroid_number_in_graph.get(centroid_counter), new Vector<Integer>()) ; 
		}
		
		Vector<Vector<Float>> centroids_respective_eigenvector_values = new Vector<Vector<Float>>();
		
		//all centroid vectors eigenvector values
		for (int centroid_counter = 0 ; centroid_counter < centroid_number_in_graph.size() ; centroid_counter++ )
		{
			int value_taken_from = centroid_number_in_graph.get(centroid_counter);
			Vector<Float> current_centroid_values = new Vector<Float>() ; 
			for (int counter_eigen_vectors =0  ; counter_eigen_vectors < eigen_vector.size() ; counter_eigen_vectors++)
			{
				current_centroid_values.add(eigen_vector.get(counter_eigen_vectors).get(value_taken_from));
			}
			centroids_respective_eigenvector_values.add(current_centroid_values) ; 
		}
		
		// for each element 
		for (int node_counter = 0 ; node_counter < eigen_vector.get(0).size() ; node_counter++ )
		{
			Vector<Float> eigen_vector_value_for_this_node = new Vector<Float>();
			
			// collecting eigenvector value from each vector for this node
			for (int counter_eigen_vectors =0  ; counter_eigen_vectors < eigen_vector.size() ; counter_eigen_vectors++)
			{
				eigen_vector_value_for_this_node.add(eigen_vector.get(counter_eigen_vectors).get(node_counter));
			}	
			
			//minimum of dsij value store 
			
			// intially set to max
			float min_of_dsij = Float.MAX_VALUE ; 
			int centroid_no_corresponding_to_that ; 
			
			// finding nearest centroid
			for (int centroid_counter = 0 ; centroid_counter < centroid_number_in_graph.size() ; centroid_counter++ )
			{
				
			}
			
		}
		return centroid_no_to_element_vec ; 
	}
	
	public float dis_similar_measure(Vector<Float> curr_node , Vector<Float> curr_centroid)
	{
		float Dsij = 0 ; 
		
		return Dsij ; 
	}
	
	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		
	}

}
